<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Dibujo Tulipanes Animado</title>
<style>
  body { margin: 0; overflow: hidden; background: #fff; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const urlJSON = "https://raw.githubusercontent.com/Baque2005/public-files/refs/heads/main/2025/08/Tulipanes.json";

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let shapes = [];
let currentShape = 0;
let currentPoint = 0;
let drawing = false;
let scale = 1;
let offsetX = 0;
let offsetY = 0;

// Cargar JSON
fetch(urlJSON)
  .then(res => res.json())
  .then(data => {
    shapes = data.filter(item => item && item.coords && item.color)
                 .map(item => ({
                   coords: item.coords.filter(pt => Array.isArray(pt) && pt.length >= 2),
                   color: item.color
                 }));

    // Calcular bounding box para escalar y centrar
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    shapes.forEach(s => s.coords.forEach(([x, y]) => {
      if(x < minX) minX = x;
      if(x > maxX) maxX = x;
      if(y < minY) minY = y;
      if(y > maxY) maxY = y;
    }));

    const margin = 50; // espacio extra alrededor
    const scaleX = (canvas.width - margin*2) / (maxX - minX);
    const scaleY = (canvas.height - margin*2) / (maxY - minY);
    scale = Math.min(scaleX, scaleY);

    offsetX = (canvas.width - (maxX - minX) * scale) / 2 - minX * scale;
    offsetY = (canvas.height - (maxY - minY) * scale) / 2 - minY * scale;

    if (shapes.length > 0) requestAnimationFrame(drawStep);
  })
  .catch(err => console.error("Error cargando JSON:", err));

// Animación
function drawStep() {
  if (currentShape >= shapes.length) return;

  const shape = shapes[currentShape];
  const coords = shape.coords;
  const col = shape.color;

  ctx.strokeStyle = `rgb(${col[0]*255}, ${col[1]*255}, ${col[2]*255})`;
  ctx.fillStyle = `rgb(${col[0]*255}, ${col[1]*255}, ${col[2]*255})`;
  ctx.lineWidth = 1;

  if (!drawing) {
    ctx.beginPath();
    const first = coords[0];
    ctx.moveTo(first[0]*scale + offsetX, -first[1]*scale + offsetY);
    drawing = true;
    currentPoint = 1;
  }

  // Dibujar varias líneas por frame para animación
  let stepsPerFrame = 5;
  for (let i = 0; i < stepsPerFrame && currentPoint < coords.length; i++, currentPoint++) {
    const point = coords[currentPoint];
    ctx.lineTo(point[0]*scale + offsetX, -point[1]*scale + offsetY);
  }
  ctx.stroke();

  if (currentPoint >= coords.length) {
    ctx.closePath();
    ctx.fill();
    currentShape++;
    drawing = false;
  }

  requestAnimationFrame(drawStep);
}

// Ajustar canvas al redimensionar ventana
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});
</script>
</body>
</html>
