<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Tulipanes Animado</title>
<style>
  body { margin:0; overflow:hidden; background:#fff; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const urlJSON = "https://raw.githubusercontent.com/Baque2005/public-files/refs/heads/main/2025/08/Tulipanes.json";

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let shapes = [];
let shapeIndex = 0;
let pointIndex = 0;
let drawing = false;
let scale = 1;
let offsetX = 0;
let offsetY = 0;

// Nueva funci칩n para calcular escala y offset
function calculateTransform() {
  let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
  shapes.forEach(s => s.coords.forEach(([x,y])=>{
    if(x<minX) minX=x; if(x>maxX) maxX=x;
    if(y<minY) minY=y; if(y>maxY) maxY=y;
  }));

  const margin = 50;
  scale = Math.min(
    (canvas.width - margin*2)/(maxX-minX),
    (canvas.height - margin*2)/(maxY-minY)
  );
  offsetX = (canvas.width - (maxX-minX)*scale)/2 - minX*scale;
  offsetY = (canvas.height - (maxY-minY)*scale)/2 - minY*scale;
}

fetch(urlJSON)
  .then(res => res.json())
  .then(data => {
    shapes = data.filter(item => item.coords && item.color);
    calculateTransform();
    requestAnimationFrame(drawStep);
  });

function drawStep(){
  if(shapeIndex >= shapes.length) return;

  const shape = shapes[shapeIndex];
  const coords = shape.coords;
  const color = shape.color;

  if(!drawing){
    ctx.beginPath();
    const [x0,y0] = coords[0];
    ctx.moveTo(x0*scale + offsetX, y0*scale + offsetY);
    pointIndex = 1;
    drawing = true;
  }

  const stepsPerFrame = 40; // Menor valor para animaci칩n m치s lenta
  for(let i=0;i<stepsPerFrame && pointIndex<coords.length;i++,pointIndex++){
    const [x,y] = coords[pointIndex];
    ctx.lineTo(x*scale + offsetX, y*scale + offsetY);
  }

  ctx.strokeStyle = `rgb(${color[0]*255},${color[1]*255},${color[2]*255})`;
  ctx.stroke();

  if(pointIndex >= coords.length){
    ctx.closePath();
    ctx.fillStyle = `rgb(${color[0]*255},${color[1]*255},${color[2]*255})`;
    ctx.fill();
    shapeIndex++;
    drawing = false;
  }

  requestAnimationFrame(drawStep);
}

window.addEventListener('resize',()=>{
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  if(shapes.length > 0){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    calculateTransform();
    // Reinicia animaci칩n
    shapeIndex = 0;
    pointIndex = 0;
    drawing = false;
    requestAnimationFrame(drawStep);
  }
});
</script>
</body>
</html>
