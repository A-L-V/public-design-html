<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Tulipanes Animado</title>
<style>
  body { margin:0; overflow:hidden; background:#fff; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const urlJSON = "https://raw.githubusercontent.com/Baque2005/public-files/refs/heads/main/2025/08/Tulipanes.json";
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let shapes = [];
let shapeIndex = 0;
let pointIndex = 0;
let drawing = false;
let scale = 1;
let offsetX = 0;
let offsetY = 0;

// Ajusta canvas a toda pantalla con DPI
function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = window.innerWidth + "px";
  canvas.style.height = window.innerHeight + "px";
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr,dpr);
}

// Calcula escala y offsets para centrar y ajustar la flor
function calculateTransform() {
  let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
  shapes.forEach(s => s.coords.forEach(([x,y])=>{
    if(x<minX) minX=x; if(x>maxX) maxX=x;
    if(y<minY) minY=y; if(y>maxY) maxY=y;
  }));

  const margin = 20; // margen en px
  const drawWidth = window.innerWidth - margin*2;
  const drawHeight = window.innerHeight - margin*2;
  scale = Math.min(drawWidth/(maxX-minX), drawHeight/(maxY-minY));

  offsetX = (window.innerWidth - (maxX-minX)*scale)/2 - minX*scale;
  offsetY = (window.innerHeight - (maxY-minY)*scale)/2 - minY*scale;
}

function drawStep(){
  if(shapeIndex >= shapes.length) return;

  const shape = shapes[shapeIndex];
  const coords = shape.coords;
  const color = shape.color;

  if(!drawing){
    ctx.beginPath();
    const [x0,y0] = coords[0];
    ctx.moveTo(x0*scale + offsetX, y0*scale + offsetY);
    pointIndex = 1;
    drawing = true;
  }

  const stepsPerFrame = 20; // más alto = animación más rápida
  for(let i=0;i<stepsPerFrame && pointIndex<coords.length;i++,pointIndex++){
    const [x,y] = coords[pointIndex];
    ctx.lineTo(x*scale + offsetX, y*scale + offsetY);
  }

  ctx.strokeStyle = `rgb(${color[0]*255},${color[1]*255},${color[2]*255})`;
  ctx.stroke();

  if(pointIndex >= coords.length){
    ctx.closePath();
    ctx.fillStyle = `rgb(${color[0]*255},${color[1]*255},${color[2]*255})`;
    ctx.fill();
    shapeIndex++;
    drawing = false;
  }

  requestAnimationFrame(drawStep);
}

// Cargar JSON y empezar animación
fetch(urlJSON)
  .then(res=>res.json())
  .then(data=>{
    shapes = data.filter(item=>item.coords && item.color);
    resizeCanvas();
    calculateTransform();
    requestAnimationFrame(drawStep);
  });

// Redimensionar ventana
window.addEventListener('resize',()=>{
  resizeCanvas();
  if(shapes.length>0){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    calculateTransform();
    shapeIndex=0;
    pointIndex=0;
    drawing=false;
    requestAnimationFrame(drawStep);
  }
});
</script>
</body>
</html>
